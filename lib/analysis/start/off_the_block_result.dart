import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:swim_apps_shared/swim_apps_shared.dart';

import 'off_the_block_enums.dart';

class OffTheBlockResultsPage extends StatefulWidget {
  final Map<OffTheBlockEvent, Duration> markedTimestamps;
  final String? startDistance;
  final double startHeight;
  final Map<String, double>? jumpData;
  final AppUser appUser;
  final String? id; // Assuming id comes from existing saved analysis

  const OffTheBlockResultsPage(
      {super.key,
      required this.markedTimestamps,
      this.startDistance,
      required this.startHeight,
      required this.jumpData,
      required this.appUser,
      this.id});

  @override
  State<OffTheBlockResultsPage> createState() => _OffTheBlockResultsPageState();
}

class _OffTheBlockResultsPageState extends State<OffTheBlockResultsPage> {
  late final AppUser appUser;
  bool _isSaving = false;
  final _titleController = TextEditingController();

  @override
  void initState() {
    appUser = widget.appUser;
    super.initState();
  }

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }

  Future<void> _handleSave() async {
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    if (widget.id != null) {
      scaffoldMessenger.showSnackBar(
        const SnackBar(
          content: Text('This analysis is already saved'),
          backgroundColor: Colors.blueGrey,
        ),
      );
      return;
    }

    setState(() {
      _isSaving = true;
    });

    if (!mounted) return;

    final userRepository = context.read<UserRepository>();
    final analysisRepository = context.read<AnalyzesRepository>();
    final navigator = Navigator.of(context);

    try {
      if (!mounted) return;
      Swimmer? selectedSwimmer;

      if (appUser.userType == UserType.coach) {
        final swimmers =
            await userRepository.getAllSwimmersFromCoach(coachId: appUser.id);
        if (!mounted) return;

        if (swimmers.isEmpty) {
          scaffoldMessenger.showSnackBar(
            const SnackBar(
              content: Text('No swimmers found to assign analysis to.'),
              backgroundColor: Colors.orange,
            ),
          );
          if (mounted) setState(() => _isSaving = false);
          return;
        }

        selectedSwimmer = await showDialog<Swimmer>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Assign to Swimmer'),
            content: SizedBox(
              width: double.maxFinite,
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: swimmers.length,
                itemBuilder: (context, index) {
                  return ListTile(
                    title: Text(swimmers[index].name),
                    onTap: () {
                      Navigator.of(context).pop(swimmers[index]);
                    },
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('Cancel'),
              ),
            ],
          ),
        );
      } else if (appUser is Swimmer) {
        selectedSwimmer = appUser as Swimmer;
      }

      if (selectedSwimmer == null) {
        if (mounted) setState(() => _isSaving = false);
        return;
      }

      if (!mounted) return;

      final String? title = await showDialog<String>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Enter Analysis Title'),
          content: TextField(
            controller: _titleController,
            autofocus: true,
            decoration:
                const InputDecoration(hintText: 'e.g., Post-practice Start'),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop(_titleController.text.trim().isEmpty
                    ? null
                    : _titleController.text.trim());
              },
              child: const Text('Save'),
            ),
          ],
        ),
      );

      if (title == null) {
        if (mounted) setState(() => _isSaving = false);
        return;
      }

      final analysisData = OffTheBlockAnalysisData(
        id: '',
        // Generated by backend
        title: title,
        date: DateTime.now(),
        swimmerId: selectedSwimmer.id,
        markedTimestamps: widget.markedTimestamps
            .map((key, value) => MapEntry(key.name, value.inMilliseconds)),
        startDistance: double.tryParse(widget.startDistance ?? '0.0') ?? 0.0,
        startHeight: widget.startHeight,
        jumpData: widget.jumpData,
        clubId: selectedSwimmer.clubId ?? '',
        coachId:
            appUser is Coach ? appUser.id : selectedSwimmer.creatorId ?? '',
        createdDate: DateTime.now(),
      );

      await analysisRepository.saveOffTheBlock(analysisData);

      if (!mounted) return;

      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text('Analysis "$title" saved for ${selectedSwimmer.name}.'),
          backgroundColor: Colors.green,
        ),
      );

      navigator.pop();
    } catch (e) {
      if (!mounted) return;
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text('Error saving analysis: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final startSignalTime =
        widget.markedTimestamps[OffTheBlockEvent.startSignal] ?? Duration.zero;

    final List<Widget> resultsWidgets =
        (widget.markedTimestamps.entries.toList()
              ..sort((a, b) => a.key.index.compareTo(b.key.index)))
            .map<Widget>((entry) {
      final eventName = entry.key.displayName;
      final relativeTime = entry.value - startSignalTime;
      final timeInSeconds =
          (relativeTime.inMilliseconds / 1000.0).toStringAsFixed(2);
      return ListTile(
        title: Text(eventName),
        trailing: Text('$timeInSeconds s'),
        dense: true,
      );
    }).toList();

    // --- Speed Metrics ---
    final timeTo5m = widget.markedTimestamps[OffTheBlockEvent.reached5m];
    final timeTo10m = widget.markedTimestamps[OffTheBlockEvent.reached10m];
    bool addedSpeedDivider = false;

    if (timeTo5m != null) {
      if (!addedSpeedDivider) {
        resultsWidgets.add(const Divider());
        addedSpeedDivider = true;
      }
      final relativeTimeTo5m = timeTo5m - startSignalTime;
      if (relativeTimeTo5m.inMilliseconds > 0) {
        final speedTo5m = 5 / (relativeTimeTo5m.inMilliseconds / 1000.0);
        resultsWidgets.add(ListTile(
          title: const Text('Average Speed to 5m'),
          trailing: Text('${speedTo5m.toStringAsFixed(2)} m/s'),
          dense: true,
        ));
      }
    }

    if (timeTo10m != null) {
      if (!addedSpeedDivider) {
        resultsWidgets.add(const Divider());
        addedSpeedDivider = true;
      }
      final relativeTimeTo10m = timeTo10m - startSignalTime;
      if (relativeTimeTo10m.inMilliseconds > 0) {
        final speedTo10m = 10 / (relativeTimeTo10m.inMilliseconds / 1000.0);
        resultsWidgets.add(ListTile(
          title: const Text('Average Speed to 10m'),
          trailing: Text('${speedTo10m.toStringAsFixed(2)} m/s'),
          dense: true,
        ));
      }
    }

    // --- Optional Stats ---
    final hasStartDistance = widget.startDistance != null &&
        widget.startDistance!.isNotEmpty &&
        double.tryParse(widget.startDistance!) != 0.0;

    if (hasStartDistance) {
      resultsWidgets.add(const Divider());
      resultsWidgets.add(ListTile(
        title: const Text('Measured Start Distance'),
        trailing: Text('${widget.startDistance} m'),
        dense: true,
      ));
    }
    resultsWidgets.add(ListTile(
      title: const Text('Start Height (Assumed)'),
      trailing: Text('${widget.startHeight.toStringAsFixed(2)} m'),
      dense: true,
    ));

    // --- Jump Physics ---
    if (widget.jumpData != null) {
      resultsWidgets.add(const Divider());
      resultsWidgets.add(
        const ListTile(
          title: Text(
            'Jump & Entry Physics',
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
          dense: true,
        ),
      );

      // Helper to safely format data
      String formatData(String key, String unit, {int decimals = 2}) {
        final value = widget.jumpData![key];
        // Check for NaN or infinite values as well
        if (value == null || value.isNaN || value.isInfinite) {
          return 'N/A';
        }
        return '${value.toStringAsFixed(decimals)} $unit';
      }

      resultsWidgets.add(ListTile(
        title: const Text('Flight Time'),
        trailing: Text(formatData('flightTime', 's')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Jump Distance (Calculated)'),
        trailing: Text(formatData('jumpDistance', 'm')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Peak Jump Height (above block)'),
        trailing: Text(formatData('maxJumpHeight', 'm')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Avg. Horizontal Velocity'),
        trailing: Text(formatData('horizontalVelocity', 'm/s')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Initial Vertical Velocity'),
        trailing: Text(formatData('initialVerticalVelocity', 'm/s')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Initial Speed (Magnitude)'),
        trailing: Text(formatData('initialVelocityMagnitude', 'm/s')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Launch Angle (vs Horizontal)'),
        trailing: Text(formatData('launchAngle', '°', decimals: 1)),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        // NEW
        title: const Text('Time to Peak Height'),
        trailing: Text(formatData('timeToPeakHeight', 's')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        // NEW
        title: const Text('Distance to Peak Height'),
        trailing: Text(formatData('distanceToPeakHeight', 'm')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Entry Velocity (Horizontal)'),
        trailing: Text(formatData('entryVelocityX', 'm/s')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Entry Velocity (Vertical)'),
        trailing: Text(formatData('entryVelocityY', 'm/s')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Entry Speed (Magnitude)'),
        trailing: Text(formatData('entryVelocityMagnitude', 'm/s')),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Entry Angle (vs Horizontal)'),
        trailing: Text(formatData('entryAngleHorizontal', '°', decimals: 1)),
        dense: true,
      ));
      resultsWidgets.add(ListTile(
        // NEW
        title: const Text('Entry Angle (vs Water)'),
        trailing: Text(formatData('entryAngleWater', '°', decimals: 1)),
        dense: true,
      ));
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Analysis Results'),
        actions: [
          if (widget.id == null)
            _isSaving
                ? const Padding(
                    padding: EdgeInsets.only(right: 16.0),
                    child: Center(
                        child: CircularProgressIndicator(color: Colors.white)),
                  )
                : IconButton(
                    icon: const Icon(Icons.save),
                    tooltip: 'Save Analysis',
                    onPressed: _handleSave,
                  ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        children: resultsWidgets,
      ),
    );
  }
}
