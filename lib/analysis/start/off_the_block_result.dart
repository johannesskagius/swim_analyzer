import 'dart:async';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:swim_apps_shared/swim_apps_shared.dart';

import 'off_the_block_analysis.dart';

class OffTheBlockResultsPage extends StatefulWidget {
  final Map<OffTheBlockEvent, Duration> markedTimestamps;
  final String? startDistance;
  final double startHeight;
  final Map<String, double>? jumpData;

  const OffTheBlockResultsPage(
      {super.key,
      required this.markedTimestamps,
      this.startDistance,
      required this.startHeight,
      required this.jumpData});

  @override
  State<OffTheBlockResultsPage> createState() => _OffTheBlockResultsPageState();
}

class _OffTheBlockResultsPageState extends State<OffTheBlockResultsPage> {
  bool _isSaving = false;

  // The title controller needs to be created and disposed properly.
  final _titleController = TextEditingController();

  @override
  void dispose() {
    _titleController.dispose();
    super.dispose();
  }

  Future<void> _handleSave() async {
    setState(() {
      _isSaving = true;
    });

    // Use a mounted check before accessing context across async gaps.
    if (!mounted) return;

    final userRepository = context.read<UserRepository>();
    final analysisRepository = context.read<AnalyzesRepository>();
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final navigator = Navigator.of(context);

    try {
      final user = await userRepository.getMyProfile();
      if (!mounted) return;

      if (user == null) {
        throw Exception("Could not find user profile. Please log in again.");
      }

      Swimmer? selectedSwimmer;

      if (user.userType == UserType.coach) {
        final swimmers =
            await userRepository.getAllSwimmersFromCoach(coachId: user.id);
        if (!mounted) return;

        selectedSwimmer = await showDialog<Swimmer>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Assign to Swimmer'),
            content: SizedBox(
              width: double.maxFinite,
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: swimmers.length,
                itemBuilder: (context, index) {
                  return ListTile(
                    title: Text(swimmers[index].name),
                    onTap: () {
                      Navigator.of(context).pop(swimmers[index]);
                    },
                  );
                },
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('Cancel'),
              ),
            ],
          ),
        );
      } else if (user is Swimmer) {
        selectedSwimmer = user;
      }

      if (selectedSwimmer == null) {
        // User cancelled swimmer selection, just stop loading and return.
        if (mounted) {
          setState(() {
            _isSaving = false;
          });
        }
        return;
      }

      if (!mounted) return;

      final String? title = await showDialog<String>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Enter Analysis Title'),
          content: TextField(
            controller: _titleController,
            autofocus: true,
            decoration:
                const InputDecoration(hintText: 'e.g., Post-practice Start'),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                Navigator.of(context).pop(_titleController.text);
              },
              child: const Text('Save'),
            ),
          ],
        ),
      );

      if (title == null || title.isEmpty) {
        // User cancelled title entry, stop loading and return.
        if (mounted) {
          setState(() {
            _isSaving = false;
          });
        }
        return;
      }

      final analysisData = OffTheBlockAnalysisData(
        id: '',
        // This will be generated by the backend.
        title: title,
        date: DateTime.now(),
        swimmerId: selectedSwimmer.id,
        markedTimestamps: widget.markedTimestamps
            .map((key, value) => MapEntry(key.name, value.inMilliseconds)),
        startDistance: double.tryParse(widget.startDistance ?? '0.0') ?? 0.0,
        startHeight: widget.startHeight,
        jumpData: widget.jumpData,
        clubId: selectedSwimmer.clubId ?? '',
        coachId: user is Coach ? user.id : selectedSwimmer.creatorId ?? '',
        createdDate: DateTime.now(),
      );

      await analysisRepository.saveOffTheBlock(analysisData);

      if (!mounted) return;

      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text('Analysis "$title" saved for ${selectedSwimmer.name}.'),
          backgroundColor: Colors.green,
        ),
      );

      // After successful save, pop the results page.
      navigator.pop();
    } catch (e) {
      if (!mounted) return;
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text('Error saving analysis: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      if (mounted) {
        setState(() {
          _isSaving = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final startSignalTime =
        widget.markedTimestamps[OffTheBlockEvent.startSignal] ?? Duration.zero;

    final List<Widget> resultsWidgets =
        (widget.markedTimestamps.entries.toList()
              ..sort((a, b) => a.key.index.compareTo(b.key.index)))
            .map<Widget>((entry) {
      final eventName = entry.key.displayName;
      final relativeTime = entry.value - startSignalTime;
      final timeInSeconds =
          (relativeTime.inMilliseconds / 1000.0).toStringAsFixed(2);
      return ListTile(
        title: Text(eventName),
        trailing: Text('$timeInSeconds s'),
      );
    }).toList();

    // Calculate and add speed metrics
    final timeTo5m = widget.markedTimestamps[OffTheBlockEvent.reached5m];
    final timeTo10m = widget.markedTimestamps[OffTheBlockEvent.reached10m];

    if (timeTo5m != null || timeTo10m != null) {
      resultsWidgets.add(const Divider());
    }

    if (timeTo5m != null) {
      final relativeTimeTo5m = timeTo5m - startSignalTime;
      if (relativeTimeTo5m.inMilliseconds > 0) {
        final speedTo5m = 5 / (relativeTimeTo5m.inMilliseconds / 1000.0);
        resultsWidgets.add(ListTile(
          title: const Text('Average Speed to 5m'),
          trailing: Text('${speedTo5m.toStringAsFixed(2)} m/s'),
        ));
      }
    }

    if (timeTo10m != null) {
      final relativeTimeTo10m = timeTo10m - startSignalTime;
      if (relativeTimeTo10m.inMilliseconds > 0) {
        final speedTo10m = 10 / (relativeTimeTo10m.inMilliseconds / 1000.0);
        resultsWidgets.add(ListTile(
          title: const Text('Average Speed to 10m'),
          trailing: Text('${speedTo10m.toStringAsFixed(2)} m/s'),
        ));
      }
    }

    // Add optional stats
    if ((widget.startDistance != null && widget.startDistance!.isNotEmpty)) {
      resultsWidgets.add(const Divider());
    }

    if (widget.startDistance != null && widget.startDistance!.isNotEmpty) {
      resultsWidgets.add(ListTile(
        title: const Text('Start Distance'),
        trailing: Text('${widget.startDistance} m'),
      ));
    }
    resultsWidgets.add(ListTile(
      title: const Text('Start Height'),
      trailing: Text('${widget.startHeight} m'),
    ));

    if (widget.jumpData != null) {
      resultsWidgets.add(const Divider());
      resultsWidgets.add(
        const ListTile(
          title: Text(
            'Jump & Entry Physics',
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
        ),
      );
      resultsWidgets.add(ListTile(
        title: const Text('Peak Jump Height (above block)'),
        trailing:
            Text('${widget.jumpData!['jumpHeight']!.toStringAsFixed(2)} m'),
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Entry Velocity (Horizontal)'),
        trailing: Text(
            '${widget.jumpData!['entryVelocityX']!.toStringAsFixed(2)} m/s'),
      ));
      resultsWidgets.add(ListTile(
        title: const Text('Entry Velocity (Vertical)'),
        trailing: Text(
            '${widget.jumpData!['entryVelocityY']!.toStringAsFixed(2)} m/s'),
      ));
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Analysis Results'),
        actions: [
          if (_isSaving)
            const Padding(
              padding: EdgeInsets.only(right: 16.0),
              child: Center(child: CircularProgressIndicator()),
            )
          else
            IconButton(
              icon: const Icon(Icons.save),
              tooltip: 'Save Analysis',
              onPressed: _handleSave,
            ),
        ],
      ),
      body: ListView(
        children: resultsWidgets,
      ),
    );
  }
}
